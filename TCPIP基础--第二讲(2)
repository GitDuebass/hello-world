那会导致一个什么样的情况呢？一个PC发送一个数据出来，可能不断的在这个网络中去打转，这个时候其实呢就进入了一个死循环是吧，对于我们的内部带宽或者设备来讲都是一种额外的负担，怎么去规避这种环路的现象呢，对于三层的分组来讲，就是IP包来讲呢，我们在IP的信封里边就是IP的头部中有这样一个ttl值，当我数据的发送方把一个IP的分组发出去的时候呢，我在这个ttl值里面，写入一个值，比如64.号，那么这个IP的报文，在每经过一个路由器，或者其他的一个三层设备做一个转发的时候，那么这个TTL值都会被减1，搜到的是64对吧，减一变63了发出去，他呢83减1,62发出去，那么当一个报文，TTL值等于1了，这个时候我如果收到这个包，我要减一嘛，一减等于0，当一个数据包他的ttl值被减为0时，这个数据包就会被丢弃，然后这个路由器就会想发送这个数据包的起来发送一个报错消息，告诉他你的报文，ttl超时了，我把他给扔了啊，就这个意思哈。发送的这个报错消息其实是一个ICMP消息。供因特网控制消息协议。ICMP消息往往用来做网管，抑制的一个轻量的协议。非常的有用，那么还有个协议号字段，那么协议字段类似信封里“内有什么什么”，比如说内有文件一份，我们写在外面那个信封上，我们看到这个信封上写的内有文件一份，我们就知道里面装了一个文件，这个字段跟这个是一模一样的（protocol）。他用来告诉接收方，你的data里边是一些什么样的报文，你比如说你后面就是一个TCP的头了，我这个protocol就会填上这个字段用来指向TCP。或者UDP我也会有一个特定的值用来指向你，这个值呢都是大家约定的，众所周知的一个值，然后还有一个头的校验荷，其作用就是用来检查我们数据在传递的过程中有木有出现什么差错，有木有被损坏啊等等，。比如我这个数据发出去的时候我给我的头部呢做一个算法，用一个算法来做个计算，把我的计算的结果呢填充到校验荷，那么这个数据的接收方，就是下一跳收到这个数据后呢他也要做一个相同算法的计算，然后再把自己的计算结果呢跟你在这里填的这个结果做比对，如果发现不一致，那么就说明这个数据包在传递的过程中被损坏了。然后就是一个叫源IP地址对吧，还有目的IP地址。我这个数据的发送方和接收方，还有一些可选的字段，这个我们就不讲了哈~~这就是一个IP报文的格式。再后面呢我们会给大家来讲数据的抓包，通过抓包去更深层次的去了解一下这个数据通信。所有的东西其实都是越底层越有难度，越能去剖析越能真正的看清楚一个东西的本质。好除了IP以外呢，我们在因特网层还有一些重要的协议，比如说ARP(Address Resolution Protocol),其实这个ARP在哪个层次是有争议的哈，有的说他是一个2.5层协议。有人说他是个2层协议，有人说他是个三层协议。其实是跟他的功能是有关系。我们前面说了，对于一个LAN来讲，比如说我这里是一个交换机，上面可能连了PC1/PC2，我的IP地址呢是192.168.1.1，我的网卡的MAC地址是假设是MAC-x哈~~这是192.168.1.2，网卡的MAC呢假设是MAC-Y,那么当PC1PC2之间要通信的时候，我们前面说了至少需要具备两个条件，第一PC1要知道PC2的IP，第二PC1还要知道PC2的MAC地址，这是为什么呢？ 因为我在写信给你的时候，需要第四层头部，第三层头部，是不是要填上源地址和目的地址对吧，所以肯定得知道我的IP地址和你的IP地址，这是肯定。与此同时呢，我还要继续构造二层头部，这是一个交换机，所以这是一个以太网的环境，所以我就要在第二层加一个以太网的帧头，那么既然是以太网的帧头肯定是要填源和目的MAC地址的，那么源MAC地址当然是MAC-X,而目的MAC地址是什么呢，不知道啊，怎么办呢？我虽然知道了你的IP地址但是我不知道你的MAC地址，这个时候呢就必须要知道PC2对应的MAC咋办？这个时候呢PC1就会吼一句，他说192.168.1.2是谁啊，这交换机上连接的所有PC都会收到，但是由于他们的IP地址都不是192.168.1.2，所以他们都会忽略这个广播，只有PC2会响应，为什么呢？因为它发现PC1吼的这个广播请求的地址正好就是我自己的地址，所以PC2会给他回一个单播的数据帧告诉他，你别吼了我的MAC地址是Y，这样的话呢PC1就知道了PC2对应的MAC地址，那么他呢就会把PC2的IP地址对应上PC2的MAC，形成一个表项，把他存放到自己的一个表格当中，这个表格就是ARP表。而这个协议用来帮助PC1拿到这个IP对应的MAC地址的这个协议呢就叫做ARP，地址解析协议。好，所以其实呢，ARP这个协议呢从这个侧面上来讲呢我们说他是整个IPV4网络的一个非常底层的非常非常基本的一个协议，可以说如果没有ARP协议，IPV4的这个局域网呢他可能就很难运作了对吧~~但是呢ARP这个协议呢他又有自己非常大的问题，比如说第一个问题，他是通过广播来请求我的目标IP对应的MAC地址，而广播我们前面反复强调过，他是有危害的对吧，尤其是当你网络中存在大量ARP的时候，对于网络来讲就是不敢重负了哈~~这是第一个问题。第二个问题他是不可靠的，而且他是不安全的，为什么这么讲呢？因为他没有任何的确认机制，他是不可靠的，他的这个分组的格式就是这是他的二层的帧头，那么这是源MAC，这是目的MAC，后面就是ARP的分组，里头呢是有重要的四个字段，分别是发送者的IP，发送者的MAC,目标的IP，目标的MAC。当我PC1去请求PC2的MAC地址的时候，我发送一个广播的ARP的请求消息，这个时候，源MAC地址是PC1自己的MAC，目的MAC是全FF的，这是一个广播的数据帧，只要你看到一个数据帧，他的目的MAC地址是全1的就是全FFFF.FFFFF的地址，那么他就是一个广播的数据帧，因为我不知道这个人在哪嘛，我就吼一句嘛，广播嘛~~好，发送者的IP是PC1的IP，发送者的MAC是发送者的MAC，而目标IP呢就是PC2的IP，而目标MAC因为这个时候他不知道，他填的就是0.0.0.0是全0的，好！！当这个时候PC2收到这个ARP消息的时候，他会给PC1回送一个ARP消息，这么一来一回呢，PC1就构成了一个表项，把PC2的IP和MAC做一个对应。看上去好像很和谐，但是我们来考虑这样一个场景，因为ARP这个协议呢是完全不需要确认的，所以你根本就不知道发送消息给我的这个哥们究竟是谁，我不需要做确认的，那这样的话就会出现问题。这是PC1，这事网关路由器，这事外网，那么PC1他的IP地址是192.168.1.1，那么接口的IP呢是192.168.1.254，PC1呢把他的这个网关设置成1.254，这样呢让他除外网的时候呢就可以把他的数据给网关让网关把数据往外网转发，一切好像都没问题对吧~~这个时候假设有一个使坏的一个人，他向网络中发送一个ARP消息，比如说发一个ARP的应答消息，然后发向PC1那么这个时候，他发送的这个ARP消息是他自己伪造的，那么他填写的发送的IP地址填成192.168.1.254的IP，但是她填的这个发送者的MAC填的是他自己的MAC，而不是路由器这个真实的MAC，他填的是一个虚假的MAC,这样一来呢会有什么样的问题~~当他把这个数据发给PC1的时候，PC1不做任何的确认，他直接呢就是把自己的192.168.1.254的网关IP地址呢跟这个虚假的MAC做了一个对应，这样一来呢当他再发送数据帧去网关的时候他以为是发给网关的，其实他是发给了这个使坏的人，好这个时候坏人就可以开启一个抓包软件，然后源源不断的去分析PC1发出来的报文，这样的话可以做的事情就很多了对吧，当然轻度的一个事情就是造成PC1没法上网，重度的一个事情呢就是PC1的密码啊很么的可能就会被泄露，而且如果这个时候这个哥们他做的再隐蔽一点，他收了这个数据再帮PC1转发出去，这样就能构成一个回路对吧，然后PC1表面上看上去好像没有断网，但是其实他的这个数据都会源源不断被这个哥们给他抓下来，这就是一个典型的叫做ARP的欺骗。这个在我们园区网络里是一个非常大的问题，一个厂商呢都开发了一些安全的协议或者一些程序一些软件一些应用产品来解决ARP的这个问题。好~~足以看出ARP这个协议是多么的不可靠多么的不安全。像我们早期的一个网络的话，如果有PC中点毒什么的，可能会让整个网络都上不了网，这就是为什么我们在IPV4的下一个版本中也就是IPV6的版本里边我们把ARP取消掉了。好，然后呢在我们你的电脑上要查看ARP消息怎么去看呢？arp -a就可以看到我们每一个IP地址对应的MAC地址是多少哈~~。当然除此之外，ARP消息我们讲完了哈。那么像因特网层呢，还有一些相关的工具，我们可能会用到，你比如说ping，这个工具呢他是我们一个非常常用的用来探测从我自己本地到远端IP地址的可达性的一个非常轻量的工具，其实他的底层是用ICMP这个协议，ping应该来说是一个程序哈~~一个软件，他底层的协议是ICMP。刚才我讲过了ICMP这个协议非常重要，当我收到了对方的回应，证明我们两个之间的数据的往返通路是没有问题的，这是ping的一个工具，当你要测试远端IP的一个可达性的时候就可以ping对端的IP地址。然后这个tracert，这个在网络设备或者主机上可能命令有所不同哈~~那么他呢是可以帮我们去找出从我自己本地到目标节点之间所穿越的那一台路由器的IP地址，这样可以帮助我分析我这个数据他行走的一个路径，好所以这两个工具呢都是我们经常用来做网络分析或者是网络故障排除的一个工具，好最后呢我们通过一个详细的模型详细的一个数据通信的过程通过这个TCP/IP参考模型来给大家来做分析。深入的来介绍一下整个数据通信的过程。那么现在的话呢是这样的，我们这个表格当中所呈现的是每一个节点他的IP地址和MAC，比如PC他的IP是192.168.1.1，他的网关是路由器的这个接口的IP地址也就是192.168.1.254，好这是PC1的MAC地址，然后路由器呢这个接口他有一个MAC是这个，然后这个接口也有一个MAC是这个地址，路由器的每一个接口都有一个MAC地址哈~~好那么当PC他要去访问这台服务器的web服务的时候发生了什么事情？我们现在假设呢TCP的三次握手已经建立起来了，那么现在的话呢，其实整个过程我们完全可以通过这样一个模型来分析，就是数据包从PC的最顶层下来，被每一层次加上信封，变成10101传过来，经过路由器还原成帧，查看帧头，再到网络层查看目的IP地址，路由下来这儿这儿。。。最终到达服务的最顶层。好这是一个宏观的分析。OK，从宏观到微观，从抽象到具像，这是我自己像大家推荐的学习方法或者说阐述一个问题的方法。那么PC呢构造了一个数据帧，这个其实呢是PC的一个HTTP进程，顶层的进程她构造了哈~~那么这个数据呢最终是要把他传到这个server上，然后我们来看一下，首先已经到了传输层对吧，因为http呢是一个基于TCP的开发的一个应用，所以他到了传输层用的是TCP的，那么就要加一个TCP的头部，那么在这个TCP头部中呢是要写上我的源端口号这个对于PC来讲呢是一个随机产生的端口号，那么目的端口号呢就是对端服务器他自己在侦听的那个端口号，缺省是80端口。当然有的服务器可能自定义了一个端口号，事先你要知道，你要访问对Ok~~再往下到了因特网层，到了因特网层呢要加一个IP的头，在这个IP的头里头会写入源IP地址和目的IP地址，还有协议号6.这个6表示的是什么呢，表示的是我这个IP的后面躲着一个TCP的头部，OK~再往下到了数据链路层，要封装一个以太网的帧头，以太网的帧头里边就要写入什么呢？因为你这个IP只关心从这儿到这儿，这是一个逻辑的路径，但是我们要务实啊，要脚踏实地啊，这个数据不可能穿越过来啊，你要先把他放到这儿，然后再到这儿，再到这儿，这个概念，那么为了让这个数据能够正常的被传到链路的另外一端，R1的GE0/0/0接口上，我要给这个数据呢写上一个以太网的帧头，那么这个帧头当中就要写地址了，对于以太网来讲呢就要写MAC地址，注意MAC地址只有在以太网环境中才会有这个地址哈~~好那么源MAC就是这个PC的网卡MAC地址，而目的MAC是PC的网关IP地址所对应的MAC地址，也就是这个R1的GE0/0/0接口的MAC。当然初始的情况他可能没有这个MAC他可能要去发送ARP的广播请求，然后拿到这个MAC以后，再去写哈~~然后类型字段呢用来指示这后面躲了一个，如0800表示后面是一个IPV4的报文。然后呢就把他变成1010发出去给R1，那么R1收到这个数据以后，先把他还原成帧，然后查看帧头，这个帧头上面写着，目的MAC地址正好就是自己的GE0/0/0接口的MAC地址，他高兴死了，他说哎哟喂有人给我写了一封信，那么他就从这个0800这个类型字段可以判断出来这后面是一个IPV4的数据，所以他把帧头拆掉，然后把后面这个数据呢交给自己的IPV4协议zan去处理，IPV4协议zan在处理这个数据的时候查看他的IP头，然后他发现哎哟喂这个目的IP地址是192.168.2.1，而2.1又不是自己的任何一个接口的IP地址，证明什么呢，证明这个数据包不是给自己的，那么怎么办呢？他就会拿着这个地址去他的地图里边，也就是路由表当中去查找，那么这个时候路由器他可能会拥有到整个网络的每一个角落的路由路径，他找到这个路径，他发现这个数据包是需要从这个GE0/0/1接扔出去扔给R2的GE0/0/0接口，那么这个时候呢他会把这个数据呢再给她加上一个新的帧头，这个时候源MAC地址是这个GE0/0/0接口的MAC地址，而目的MAC是R2的GE0/0/0的MAC地址，然后把数据帧发给R2，R2收到这个数据后一样的，发现这个帧头是给自己的，满心欢喜，拆掉这个帧头给自己IPV4协议zan去处理，IPV4协议zan发现这个目的IP不是自己但是呢是本地的一个直连的网段，于是乎他就把这个数据呢再给她写上一个帧头，这个时候目的MAC地址就是server的MAC地址，然后把这个数据帧发送给server，server收到这个数据帧查看帧头目的MAC地址就是自己的MAC，把帧头拆掉把里头的数据呢交给IP协议zan去处理，IP协议zan的话呢看到这个目的IP地址就是自己的IP地址，于是乎他把这个IP头呢也拆掉，通过这个协议号6知道后面是一个TCP的头部，于是乎把后面这一部分交给TCP协议去处理，TCP协议zan发现这个谜底端口号是80端口，于是乎呢他又看一下本地TCP的80端口开没开，发现开了，而且是HTTP的进程在帧头，那么这个时候就会把TCP的这个头部也会去掉，然后把这里头的数据交给http的进程去处理，大功告成，这就是我们整个数据通信的过程。
